/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => ThreeStateChecklistPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// types.ts
var CheckboxState;
(function(CheckboxState3) {
  CheckboxState3["UNCHECKED"] = "unchecked";
  CheckboxState3["CHECKED"] = "checked";
  CheckboxState3["CANCELLED"] = "cancelled";
})(CheckboxState || (CheckboxState = {}));
var DEFAULT_SETTINGS = {
  enabled: true
};

// services/checkbox-service.ts
var CheckboxService = class {
  static getNextState(currentState) {
    switch (currentState) {
      case CheckboxState.UNCHECKED:
        return CheckboxState.CHECKED;
      case CheckboxState.CHECKED:
        return CheckboxState.CANCELLED;
      case CheckboxState.CANCELLED:
        return CheckboxState.UNCHECKED;
      default:
        return CheckboxState.UNCHECKED;
    }
  }
  static getCheckboxState(element) {
    const checkbox = element.querySelector(".task-list-item-checkbox");
    if (!checkbox)
      return CheckboxState.UNCHECKED;
    if (element.classList.contains("is-cancelled")) {
      return CheckboxState.CANCELLED;
    }
    return checkbox.checked ? CheckboxState.CHECKED : CheckboxState.UNCHECKED;
  }
  static updateCheckboxState(element, state) {
    const checkbox = element.querySelector(".task-list-item-checkbox");
    if (!checkbox)
      return;
    switch (state) {
      case CheckboxState.CHECKED:
        checkbox.checked = true;
        element.classList.remove("is-cancelled");
        break;
      case CheckboxState.CANCELLED:
        checkbox.checked = true;
        element.classList.add("is-cancelled");
        break;
      case CheckboxState.UNCHECKED:
        checkbox.checked = false;
        element.classList.remove("is-cancelled");
        break;
    }
  }
};

// services/editor-service.ts
var EditorService = class {
  constructor(view) {
    this.view = view;
    this.view = view;
  }
  getLineNumberFromElement(element) {
    const taskItems = Array.from(document.querySelectorAll(".task-list-item"));
    const el = element.closest(".task-list-item");
    if (el === null)
      return -1;
    let index = taskItems.indexOf(el);
    if (index === -1)
      return -1;
    const editor = this.view.editor;
    const totalLines = editor.lineCount();
    for (let i = 0; i < totalLines; i++) {
      const line = editor.getLine(i);
      if (line.match(/^\s*[-*+]\s*\[[ x]\]/i)) {
        if (index === 0)
          return i;
        index--;
      }
    }
    return -1;
  }
  updateCheckboxInLine(lineNumber, state) {
    const editor = this.view.editor;
    const line = editor.getLine(lineNumber);
    const newLine = line.replace(/\[[\sx]\]/i, state === CheckboxState.UNCHECKED ? "[ ]" : state === CheckboxState.CHECKED ? "[x]" : "[x]");
    editor.transaction({
      changes: [
        {
          from: { line: lineNumber, ch: 0 },
          to: { line: lineNumber, ch: line.length },
          text: newLine
        }
      ]
    });
  }
};

// main.ts
var ThreeStateChecklistPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.editorService = null;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.loadStyles();
      this.registerCheckboxClickHandler();
    });
  }
  registerCheckboxClickHandler() {
    this.registerDomEvent(document, "click", (evt) => {
      const target = evt.target;
      if (!target.classList.contains("task-list-item-checkbox")) {
        return;
      }
      evt.preventDefault();
      evt.stopPropagation();
      const listItem = target.closest(".task-list-item");
      if (!listItem)
        return;
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!view)
        return;
      if (!this.editorService || view !== this.editorService.view) {
        this.editorService = new EditorService(view);
      }
      const currentState = CheckboxService.getCheckboxState(listItem);
      const nextState = CheckboxService.getNextState(currentState);
      CheckboxService.updateCheckboxState(listItem, nextState);
      const lineNumber = this.editorService.getLineNumberFromElement(listItem);
      if (lineNumber !== -1) {
        this.editorService.updateCheckboxInLine(lineNumber, nextState);
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "three-state-checklist-styles";
    styleEl.textContent = `
      .task-list-item-checkbox {
        border-radius: 0 !important;
      }

      .task-list-item-checkbox:checked {
        background-color: var(--interactive-accent) !important;
        border-radius: 0 !important;
      }

      .task-list-item.is-cancelled .task-list-item-checkbox {
        background-color: var(--text-muted) !important;
        border-radius: 0 !important;
      }

      .task-list-item.is-cancelled .task-list-item-checkbox::after {
        content: '\xD7' !important;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        color: var(--background-primary);
      }

      .task-list-item.is-cancelled {
        text-decoration: line-through;
        color: var(--text-muted);
      }
    `;
    document.head.appendChild(styleEl);
  }
  onunload() {
    const styleEl = document.getElementById("three-state-checklist-styles");
    if (styleEl) {
      styleEl.remove();
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJ0eXBlcy50cyIsICJzZXJ2aWNlcy9jaGVja2JveC1zZXJ2aWNlLnRzIiwgInNlcnZpY2VzL2VkaXRvci1zZXJ2aWNlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUGx1Z2luU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MsIENoZWNrYm94U3RhdGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgQ2hlY2tib3hTZXJ2aWNlIH0gZnJvbSBcIi4vc2VydmljZXMvY2hlY2tib3gtc2VydmljZVwiO1xuaW1wb3J0IHsgRWRpdG9yU2VydmljZSB9IGZyb20gXCIuL3NlcnZpY2VzL2VkaXRvci1zZXJ2aWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRocmVlU3RhdGVDaGVja2xpc3RQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3M7XG4gIHByaXZhdGUgZWRpdG9yU2VydmljZTogRWRpdG9yU2VydmljZSB8IG51bGwgPSBudWxsO1xuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIHRoaXMubG9hZFN0eWxlcygpO1xuICAgIHRoaXMucmVnaXN0ZXJDaGVja2JveENsaWNrSGFuZGxlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckNoZWNrYm94Q2xpY2tIYW5kbGVyKCkge1xuICAgIHRoaXMucmVnaXN0ZXJEb21FdmVudChkb2N1bWVudCwgXCJjbGlja1wiLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAvLyBDaGVjayBpZiBjbGlja2VkIGVsZW1lbnQgaXMgYSBjaGVja2JveFxuICAgICAgaWYgKCF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGFzay1saXN0LWl0ZW0tY2hlY2tib3hcIikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgY2hlY2tib3ggYmVoYXZpb3JcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBjb25zdCBsaXN0SXRlbSA9IHRhcmdldC5jbG9zZXN0KFwiLnRhc2stbGlzdC1pdGVtXCIpO1xuICAgICAgaWYgKCFsaXN0SXRlbSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgIGlmICghdmlldykgcmV0dXJuO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGVkaXRvciBzZXJ2aWNlIGlmIG5lZWRlZFxuICAgICAgaWYgKCF0aGlzLmVkaXRvclNlcnZpY2UgfHwgdmlldyAhPT0gdGhpcy5lZGl0b3JTZXJ2aWNlLnZpZXcpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JTZXJ2aWNlID0gbmV3IEVkaXRvclNlcnZpY2Uodmlldyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlIGFuZCBjYWxjdWxhdGUgbmV4dCBzdGF0ZVxuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gQ2hlY2tib3hTZXJ2aWNlLmdldENoZWNrYm94U3RhdGUobGlzdEl0ZW0pO1xuICAgICAgY29uc3QgbmV4dFN0YXRlID0gQ2hlY2tib3hTZXJ2aWNlLmdldE5leHRTdGF0ZShjdXJyZW50U3RhdGUpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNoZWNrYm94IHN0YXRlIGluIERPTVxuICAgICAgQ2hlY2tib3hTZXJ2aWNlLnVwZGF0ZUNoZWNrYm94U3RhdGUobGlzdEl0ZW0sIG5leHRTdGF0ZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbWFya2Rvd24gY29udGVudFxuICAgICAgY29uc3QgbGluZU51bWJlciA9IHRoaXMuZWRpdG9yU2VydmljZS5nZXRMaW5lTnVtYmVyRnJvbUVsZW1lbnQobGlzdEl0ZW0pO1xuICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yU2VydmljZS51cGRhdGVDaGVja2JveEluTGluZShsaW5lTnVtYmVyLCBuZXh0U3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRTdHlsZXMoKSB7XG4gICAgY29uc3Qgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBzdHlsZUVsLmlkID0gXCJ0aHJlZS1zdGF0ZS1jaGVja2xpc3Qtc3R5bGVzXCI7XG4gICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IGBcbiAgICAgIC50YXNrLWxpc3QtaXRlbS1jaGVja2JveCB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgLnRhc2stbGlzdC1pdGVtLWNoZWNrYm94OmNoZWNrZWQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1pbnRlcmFjdGl2ZS1hY2NlbnQpICFpbXBvcnRhbnQ7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgLnRhc2stbGlzdC1pdGVtLmlzLWNhbmNlbGxlZCAudGFzay1saXN0LWl0ZW0tY2hlY2tib3gge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10ZXh0LW11dGVkKSAhaW1wb3J0YW50O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAwICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIC50YXNrLWxpc3QtaXRlbS5pcy1jYW5jZWxsZWQgLnRhc2stbGlzdC1pdGVtLWNoZWNrYm94OjphZnRlciB7XG4gICAgICAgIGNvbnRlbnQ6ICdcdTAwRDcnICFpbXBvcnRhbnQ7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgY29sb3I6IHZhcigtLWJhY2tncm91bmQtcHJpbWFyeSk7XG4gICAgICB9XG5cbiAgICAgIC50YXNrLWxpc3QtaXRlbS5pcy1jYW5jZWxsZWQge1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcbiAgICAgICAgY29sb3I6IHZhcigtLXRleHQtbXV0ZWQpO1xuICAgICAgfVxuICAgIGA7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIGNvbnN0IHN0eWxlRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRocmVlLXN0YXRlLWNoZWNrbGlzdC1zdHlsZXNcIik7XG4gICAgaWYgKHN0eWxlRWwpIHtcbiAgICAgIHN0eWxlRWwucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG4iLCAiZXhwb3J0IGVudW0gQ2hlY2tib3hTdGF0ZSB7XG4gIFVOQ0hFQ0tFRCA9ICd1bmNoZWNrZWQnLFxuICBDSEVDS0VEID0gJ2NoZWNrZWQnLFxuICBDQU5DRUxMRUQgPSAnY2FuY2VsbGVkJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpblNldHRpbmdzIHtcbiAgZW5hYmxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpblNldHRpbmdzID0ge1xuICBlbmFibGVkOiB0cnVlXG59OyIsICJpbXBvcnQgeyBDaGVja2JveFN0YXRlIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBDaGVja2JveFNlcnZpY2Uge1xuICBzdGF0aWMgZ2V0TmV4dFN0YXRlKGN1cnJlbnRTdGF0ZTogQ2hlY2tib3hTdGF0ZSk6IENoZWNrYm94U3RhdGUge1xuICAgIHN3aXRjaCAoY3VycmVudFN0YXRlKSB7XG4gICAgICBjYXNlIENoZWNrYm94U3RhdGUuVU5DSEVDS0VEOlxuICAgICAgICByZXR1cm4gQ2hlY2tib3hTdGF0ZS5DSEVDS0VEO1xuICAgICAgY2FzZSBDaGVja2JveFN0YXRlLkNIRUNLRUQ6XG4gICAgICAgIHJldHVybiBDaGVja2JveFN0YXRlLkNBTkNFTExFRDtcbiAgICAgIGNhc2UgQ2hlY2tib3hTdGF0ZS5DQU5DRUxMRUQ6XG4gICAgICAgIHJldHVybiBDaGVja2JveFN0YXRlLlVOQ0hFQ0tFRDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBDaGVja2JveFN0YXRlLlVOQ0hFQ0tFRDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hlY2tib3hTdGF0ZShlbGVtZW50OiBFbGVtZW50KTogQ2hlY2tib3hTdGF0ZSB7XG4gICAgY29uc3QgY2hlY2tib3ggPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIi50YXNrLWxpc3QtaXRlbS1jaGVja2JveFwiLFxuICAgICkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBpZiAoIWNoZWNrYm94KSByZXR1cm4gQ2hlY2tib3hTdGF0ZS5VTkNIRUNLRUQ7XG5cbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1jYW5jZWxsZWRcIikpIHtcbiAgICAgIHJldHVybiBDaGVja2JveFN0YXRlLkNBTkNFTExFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tib3guY2hlY2tlZCA/IENoZWNrYm94U3RhdGUuQ0hFQ0tFRCA6IENoZWNrYm94U3RhdGUuVU5DSEVDS0VEO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZUNoZWNrYm94U3RhdGUoZWxlbWVudDogRWxlbWVudCwgc3RhdGU6IENoZWNrYm94U3RhdGUpOiB2b2lkIHtcbiAgICBjb25zdCBjaGVja2JveCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgIFwiLnRhc2stbGlzdC1pdGVtLWNoZWNrYm94XCIsXG4gICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGlmICghY2hlY2tib3gpIHJldHVybjtcblxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgQ2hlY2tib3hTdGF0ZS5DSEVDS0VEOlxuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtY2FuY2VsbGVkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2hlY2tib3hTdGF0ZS5DQU5DRUxMRUQ6XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpcy1jYW5jZWxsZWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDaGVja2JveFN0YXRlLlVOQ0hFQ0tFRDpcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1jYW5jZWxsZWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvciwgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDaGVja2JveFN0YXRlIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHZpZXc6IE1hcmtkb3duVmlldykge1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gIH1cblxuICBnZXRMaW5lTnVtYmVyRnJvbUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IG51bWJlciB7XG4gICAgLy8gR2V0IGFsbCB0YXNrIGxpc3QgaXRlbXMgaW4gdGhlIGRvY3VtZW50XG4gICAgY29uc3QgdGFza0l0ZW1zID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhc2stbGlzdC1pdGVtXCIpKTtcbiAgICBjb25zdCBlbCA9IGVsZW1lbnQuY2xvc2VzdChcIi50YXNrLWxpc3QtaXRlbVwiKTtcblxuICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuIC0xO1xuXG4gICAgbGV0IGluZGV4ID0gdGFza0l0ZW1zLmluZGV4T2YoZWwpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIC0xO1xuXG4gICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBsaW5lIGluIHRoZSBlZGl0b3JcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnZpZXcuZWRpdG9yO1xuICAgIGNvbnN0IHRvdGFsTGluZXMgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsTGluZXM7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuICAgICAgaWYgKGxpbmUubWF0Y2goL15cXHMqWy0qK11cXHMqXFxbWyB4XVxcXS9pKSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHJldHVybiBpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHVwZGF0ZUNoZWNrYm94SW5MaW5lKGxpbmVOdW1iZXI6IG51bWJlciwgc3RhdGU6IENoZWNrYm94U3RhdGUpOiB2b2lkIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnZpZXcuZWRpdG9yO1xuICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcbiAgICBjb25zdCBuZXdMaW5lID0gbGluZS5yZXBsYWNlKFxuICAgICAgL1xcW1tcXHN4XVxcXS9pLFxuICAgICAgc3RhdGUgPT09IENoZWNrYm94U3RhdGUuVU5DSEVDS0VEXG4gICAgICAgID8gXCJbIF1cIlxuICAgICAgICA6IHN0YXRlID09PSBDaGVja2JveFN0YXRlLkNIRUNLRURcbiAgICAgICAgICA/IFwiW3hdXCJcbiAgICAgICAgICA6IFwiW3hdXCIsXG4gICAgKTtcblxuICAgIGVkaXRvci50cmFuc2FjdGlvbih7XG4gICAgICBjaGFuZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBmcm9tOiB7IGxpbmU6IGxpbmVOdW1iZXIsIGNoOiAwIH0sXG4gICAgICAgICAgdG86IHsgbGluZTogbGluZU51bWJlciwgY2g6IGxpbmUubGVuZ3RoIH0sXG4gICAgICAgICAgdGV4dDogbmV3TGluZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBcUM7OztBQ0E5QixJQUFLO0FBQUwsVUFBSyxnQkFBTDtBQUNMLGdDQUFZO0FBQ1osOEJBQVU7QUFDVixnQ0FBWTtBQUFBLEdBSEY7QUFVTCxJQUFNLG1CQUFtQztBQUFBLEVBQzlDLFNBQVM7QUFBQTs7O0FDVEosNEJBQXNCO0FBQUEsU0FDcEIsYUFBYSxjQUE0QztBQUM5RCxZQUFRO0FBQUEsV0FDRCxjQUFjO0FBQ2pCLGVBQU8sY0FBYztBQUFBLFdBQ2xCLGNBQWM7QUFDakIsZUFBTyxjQUFjO0FBQUEsV0FDbEIsY0FBYztBQUNqQixlQUFPLGNBQWM7QUFBQTtBQUVyQixlQUFPLGNBQWM7QUFBQTtBQUFBO0FBQUEsU0FJcEIsaUJBQWlCLFNBQWlDO0FBQ3ZELFVBQU0sV0FBVyxRQUFRLGNBQ3ZCO0FBRUYsUUFBSSxD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
